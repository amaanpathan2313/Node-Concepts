
                                                                         # Mongo DB Queries #

1. mongosh : to start mongoShell

cls : to clear

2. show dbs : Ti show all the available dataBase

3. use Ecommers : If Ecommers database are available then use it otherwise create it and use It.

4 db.createCollection("orders") : This command crete order collection inside Ecommers Database.

5. show collections :  This command show all collection inside the database.

6. db.orders.find() : Get all the document from orders collection

7. db.orders.insertMany([{},{},...]) : Add new document in order collection

                                                       #   Queries to Perform   #

8. Retrieve all orders with the order_status "shipped" ===>  db.orders.find({ order_status: "shipped" })

9. Update the total_amount of the order with order_id: 1 to 70000 ===>   Ecommers> db.orders.updateOne({order_id : 1}, {$set:{total_amount: 70000}})

10. Delete the order with order_id: 4 ===>  Ecommers> db.orders.deleteOne({order_id : 4})

11. Retrieve the order with the customer_name: "Alice Johnson" ===> Ecommers> db.orders.find({customer_name: "Alice Johnson"})

12. Update the order_status of the order with order_id: 2 to "delivered" ===>  Ecommers> db.orders.updateOne({order_id: 2}, {$set:{"order_status": "delivered"}})

13. Retrieve all orders with a total_amount greater than or equal to 15000 ===>  Ecommers> db.orders.find({"total_amount": {$gte : 15000}})

//  forLessthenEqualto ==>  { $lt: 15000 }


                                                              ##  Part - 2 ##


1. Retrieve all recipes with cuisine "Italian" ==> Hotel> db.recipes.find({cuisine:"Italian"})

2. Retrieve all recipes with a prep_time less than 30 minutes ==>  Hotel> db.recipes.find({"prep_time": {$lt : 30}})

3. Retrieve all recipes where the price is greater than 500 ==>  Hotel> db.recipes.find({ "price": {$gte : 500}})

4. Retrieve all recipes sorted by price in ascending order ==> Hotel> db.recipes.find().sort({price : 1})

5. Update the price of the recipe with recipe_id: 2 (Chicken Biryani) to 900 ==>  Hotel> db.recipes.updateOne({ "recipe_id": 2, "name": "Chicken Biryani"}, {$set:{"price": 900}})

6. Retrieve only the name and price fields for all recipes ==>  Hotel> db.recipes.find({}, { "name": 1, "price": 1})

7. Retrieve all recipes where the difficulty is "medium" and the price is less than 600 ==> Hotel> db.recipes.find({ "difficulty" : "medium", "price" : {$lt : 600}},{"difficulty" : 1, "price" : 1})
                                                                                                                                                                               ||
                                                                                                                                              //  to travel all array element  == Return all documents 

8. Retrieve all recipes sorted by prep_time in descending order ==>   Hotel> db.recipes.find().sort({"prep_time" : -1})

9. Insert a new recipe ===>     Hotel> db.recipes.insertOne({ "recipe_id": 11, 
                                 "name": "Chocolate Cake", 
                                 "ingredients": ["Flour", "Sugar", "Cocoa Powder", "Eggs", "Butter"],
                                 "cuisine": "American",
                                 "prep_time": 50,
                                 "difficulty": "medium",
                                 "price": 750 
                               })

{
  "recipe_id": 11,
  "name": "Chocolate Cake",
  "ingredients": ["Flour", "Sugar", "Cocoa Powder", "Eggs", "Butter"],
  "cuisine": "American",
  "prep_time": 50,
  "difficulty": "medium",
  "price": 750
}


10. Delete the recipe with recipe_id: 4 (Caesar Salad). ==>   Hotel> db.recipes.deleteOne({"recipe_id": 4, "name": "Caesar Salad"})

11. Retrieve all recipes with cuisine "Japanese" or "Thai". ==>  Hotel> db.recipes.find({ cuisine: { $in: ["Japanese", "Thai"] } })

12. Retrieve all recipes where the ingredients include "Egg".  ==>  Hotel> db.recipes.find({ ingredients: { $regex: /egg/i  } })    // i for case sensitivity   "Egg""egg""EGG"
  
13. Update the prep_time of the recipe with recipe_id: 7 (Pad Thai) to 35 minutes.  ==>  Hotel> db.recipes.updateOne({recipe_id: 7, name: "Pad Thai"}, {$set:{prep_time: 35}})

14. Delete all recipes where the price is greater than 1000.  ==>  Hotel> db.recipes.deleteMany({price: {$gte: 1000}})

15. Retrieve the first 3 recipes using the limit function. ==>   Hotel> db.recipes.find().limit(3)

16. Skip the first 2 recipes and retrieve the rest. ==>  Hotel> db.recipes.find().skip(2)

17. Retrieve all recipes with cuisine "Thai" and sort them by price in descending order. ==>   Hotel> db.recipes.find({"cuisine":"Thai"}).sort({price: -1})

18. Insert another new recipe:  ==>  Hotel> db.recipes.insertOne({
                                                                    "recipe_id": 12,
                                                                    "name": "Hummus",
                                                                    "ingredients": ["Chickpeas", "Tahini",
                                                                    "Garlic", "Olive Oil", "Lemon Juice"],
                                                                    "cuisine": "Middle Eastern", 
                                                                    "prep_time": 15,  
                                                                    "difficulty": "easy", 
                                                                    "price": 300
                                                                })   


19. Count the number of recipes with difficulty "easy" ===>   Hotel> db.recipes.countDocuments({"difficulty" : "easy"})

20. Retrieve all recipes with a prep_time greater than 40 minutes. ===>   Hotel> db.recipes.find({"prep_time" : {$gte : 40}})

 match: [/^[a-z\.0-9]+@[a-z]+\.[a-z]{2,3}$/, 'Please fill a valid email address'] 

$eq ==> 	Equal to                 	==>    { age: { $eq: 18 } }
$ne  ==>  Not equal to             	==>  { age: { $ne: 18 } }
$gt	==>   Greater than	            ==>  { age: { $gt: 30 } }
$gte ==> 	Greater than or equal to	==>     { age: { $gte: 18 } }
$lt  ==> 	Less than	                ==>     { age: { $lt: 65 } }
$lte ==> 	Less than or equal to	    ==>     { age: { $lte: 60 } }
$in	 ==>  Value exists in array      ==>   	{ gender: { $in: ['male', 'female'] } }
$and ==> 	Combine multiple query conditions       	==>    { $and: [{ age: { $gt: 18 } }, { isActive: true }] }
$or ==>   Match if at least one condition is true   ==>   	{ $or: [{ age: { $lt: 18 } }, { isActive: false }] }



.skip()	  ==>   Skips a certain number of results	 ==>    .find().skip(10)
.limit()  ==>	  Limits the number of results       ==>    .find().limit(5)
.sort()	  ==>   Sorts results by a field	         ==>     .find().sort({ age: -1 }) // in ascending   ||  1 for descending


| Type              | Tightly Coupled | Has _id? | Reusable | Best Use Case                                          |
|-------------------|-----------------|----------|----------|--------------------------------------------------------|
| Nested Documents  | ✅ Yes          | ❌ No    | ❌ No    | Small, non-reusable, tightly coupled data             |
|Sub documents      | ✅ Yes          | ✅ Yes   | ✅ Yes   | Structured, reusable, moderate-sized data             |
| Referenced Docs   | ❌ No           | ✅ Yes   | ✅ Yes   | Large, shared, loosely-coupled independent data       |

      ====================================        xxxxxxxxxxxxxxxxx       ======================================

const validator = require('validator');

 email: {
            type: String, required: true, validate: {
                validator: validator.isEmail,
                message: 'Invalid email format'
            }

 url: {
      type: String,
      required: true,
      validate: {
        validator: validator.isURL,
        message: 'Invalid URL format',
      },
    },




      const targetData = await UserModel.find({
            $and: [
              { 'profiles.platform': profile },
              { name: name }
            ]
          });
          













### **List Of All Functions Available In Mongo**

MongoDB provides a wide range of inbuilt functions and operators for performing operations on data. These are categorized into different groups based on their usage.

---

### **1. Query Operators**
Used in queries to filter documents based on conditions.

#### **Comparison Operators**
- `$eq`: Equal to
- `$ne`: Not equal to
- `$gt`: Greater than
- `$gte`: Greater than or equal to
- `$lt`: Less than
- `$lte`: Less than or equal to
- `$in`: Matches any value in an array
- `$nin`: Does not match any value in an array

#### **Logical Operators**
- `$and`: Logical AND
- `$or`: Logical OR
- `$not`: Logical NOT
- `$nor`: Logical NOR

#### **Element Operators**
- `$exists`: Checks if a field exists
- `$type`: Matches fields based on their BSON type

#### **Evaluation Operators**
- `$regex`: Matches a regular expression
- `$expr`: Allows the use of aggregation expressions in queries
- `$mod`: Modulus operation
- `$text`: Text search
- `$where`: Matches documents based on a JavaScript expression

---

### **2. Update Operators**
Used to update fields in documents.

#### **Field Update Operators**
- `$set`: Sets a field to a specified value
- `$unset`: Removes a field
- `$rename`: Renames a field
- `$inc`: Increments a field by a specified value
- `$mul`: Multiplies a field by a value
- `$min`: Updates the field if the specified value is less than the existing value
- `$max`: Updates the field if the specified value is greater than the existing value

#### **Array Update Operators**
- `$push`: Adds an element to an array
- `$pop`: Removes the first or last element from an array
- `$pull`: Removes elements from an array that match a condition
- `$addToSet`: Adds a value to an array only if it doesn’t already exist
- `$each`: Used with `$push` or `$addToSet` to add multiple elements
- `$slice`: Limits the number of elements in an array
- `$sort`: Sorts elements in an array

#### **Positional Operators**
- `$`: Updates the first array element that matches the query condition
- `$[]`: Updates all array elements
- `$[<identifier>]`: Updates array elements that match array filters

---

### **3. Aggregation Pipeline Operators**
Used in the aggregation framework for advanced data transformations.

#### **Pipeline Stages**
- `$match`: Filters documents
- `$group`: Groups documents by a specified key
- `$project`: Reshapes documents and includes/excludes fields
- `$sort`: Sorts documents
- `$limit`: Limits the number of documents
- `$skip`: Skips the specified number of documents
- `$unwind`: Deconstructs an array field
- `$lookup`: Performs a left outer join with another collection
- `$facet`: Processes multiple pipelines within a single stage
- `$bucket`: Categorizes documents into groups
- `$bucketAuto`: Automatically categorizes documents into groups
- `$replaceRoot`: Replaces the root document
- `$merge`: Merges the results of the pipeline into another collection

#### **Expression Operators**
- `$sum`: Calculates the sum of numeric values
- `$avg`: Calculates the average
- `$min`: Finds the minimum value
- `$max`: Finds the maximum value
- `$first`: Returns the first value
- `$last`: Returns the last value
- `$count`: Counts the number of documents
- `$concat`: Concatenates strings
- `$substr`: Extracts a substring
- `$toUpper`: Converts to uppercase
- `$toLower`: Converts to lowercase
- `$arrayElemAt`: Returns an element from an array
- `$size`: Returns the size of an array
- `$split`: Splits a string into an array

---

### **4. Array Operators**
Used to manipulate array fields.

- `$all`: Matches arrays that contain all specified elements
- `$elemMatch`: Matches documents containing an array with at least one element that matches the specified condition
- `$size`: Matches arrays with a specified number of elements

---

### **5. Text Search Operators**
- `$text`: Performs text search on a collection with a text index
- `$search`: The query string for text search
- `$language`: The language for the text search
- `$caseSensitive`: Enables case-sensitive search
- `$diacriticSensitive`: Enables diacritic-sensitive search

---

### **6. Geospatial Operators**
Used to perform queries on geospatial data.

- `$geoWithin`: Finds documents within a geometry
- `$geoIntersects`: Finds documents that intersect with a geometry
- `$near`: Finds documents near a point
- `$nearSphere`: Finds documents near a point on a sphere

---

### **7. Miscellaneous Operators**
- `$currentDate`: Sets a field to the current date
- `$type`: Matches fields based on their BSON type
- `$expr`: Allows aggregation expressions in queries
- `$jsonSchema`: Validates documents against a JSON schema

---

### **Resources for Full Reference**
For the latest and most comprehensive list of operators, refer to the [MongoDB documentation](https://www.mongodb.com/docs/manual/).




   let data = await BookModel.findById(bookId).populate('rentedBy', 'name email');